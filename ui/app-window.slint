import { ScrollView } from "std-widgets.slint";

export struct GridItem {
  image: image,
  index: int,
}

export enum ViewMode {
    full,
    grid,
}

export component MainWindow inherits Window {
    title: "Luminous";
    background: app_background;
    preferred-width: 1280px;
    preferred-height: 720px;
    full-screen: self.is_fullscreen;

    // Full view
    callback request_next_image();
    callback request_prev_image();

    // Grid view
    callback request_grid_data(int, int);
    callback image_selected(int);
    callback bucket_resolution_changed(int);

    // ContextMenuArea
    callback rotate_plus_90();
    callback rotate_minus_90();

    callback quit_app();

    in property <color> app_background: #000000;
    in property <[GridItem]> grid_model;
    in property <image> full_view_image;
    in-out property <int> curr_image_index: 0;
    in property <string> curr_image_name;
    in-out property <ViewMode> view_mode: ViewMode.full; // TODO: cache last view mode
    in-out property <bool> is_fullscreen: false;
    in-out property <int> grid_cols: 5;

    function udpate_visible_rows() {
        let item_h = grid_container.item_size + grid_container.gap;
        let cols = grid_container.cols;

        if (item_h > 1px && root.height > 1px) {
            let start_row = floor(-grid_view.viewport-y / item_h);
            let screen_rows = ceil(grid_view.height / item_h);
            let buffer_rows = 5;
            let start_index = Math.max(0, (start_row - buffer_rows) * cols);
            let total_count = (screen_rows + (buffer_rows * 2)) * cols;
            debug("udpate_visible_rows: start_index: ", start_index, " total_count: ", total_count);
            root.request_grid_data(start_index, total_count);
        }
    }

    forward-focus: my-key-handler;
    my-key-handler := FocusScope {
        key-pressed(event) => {
            if (event.text == "q") {
                root.quit_app();
                return accept;
            }
            if (event.text == "f") {
                root.is_fullscreen = !root.is_fullscreen;
                return accept;
            }
            if (root.view-mode == ViewMode.full) {
                if (event.text == "h" || event.text == Key.LeftArrow) {
                    root.request_prev_image();
                } else if (event.text == "l" || event.text == Key.RightArrow) {
                    root.request_next_image();
                } else if (event.text == Key.Escape) {
                    root.view_mode = ViewMode.grid;
                }
            } else if (root.view-mode == ViewMode.grid) {
                if (event.text == Key.Escape) {
                    root.view_mode = ViewMode.full;
                }
                if (event.text == Key.PageDown) {
                    grid_view.viewport-y = Math.max(
                        grid_view.viewport-y - grid_view.height,
                        grid_view.height - grid_view.viewport-height);
                    udpate_visible_rows();
                    return accept;
                }
                if (event.text == Key.PageUp) {
                    grid_view.viewport-y = Math.min(
                        grid_view.viewport-y + grid_view.height,
                        0px);
                    udpate_visible_rows();
                    return accept;
                }
            }
            accept
        }
    }

    grid_view := ScrollView {
        visible: root.view-mode == ViewMode.grid;
        viewport-height: grid_container.height;
        property <[length]> resolutions: [256 * 1px, 512 * 1px, 1024 * 1px]; // sync with Rust get_bucked_res()

        function bucket_resolution(size: length) -> int {
            if size < resolutions[0] {
                return resolutions[0] / 1px;
            }
            if size < resolutions[1] {
                return resolutions[1] / 1px;
            }
            return resolutions[2] / 1px;
        }
        function sync_bucket_resolution() {
            let new_bucket_res = bucket_resolution(grid_container.item_size);
            debug("new_bucket_res: ", new_bucket_res, " item_size: ", grid_container.item_size);
            if (new_bucket_res != grid_container.curr_bucket_res) {
                let old_bucket_res = grid_container.curr_bucket_res;
                grid_container.curr_bucket_res = new_bucket_res;
                root.bucket_resolution_changed(new_bucket_res);
                debug("Bucket resolution change:", old_bucket_res, "=>", grid_container.curr_bucket_res);
            }
        }

        scrolled => {
            udpate_visible_rows();
        }
        // FIX: Rust does not react on init. Does it depend on grid_container?
        init => {
            udpate_visible_rows();
        }
        // Could be refreshed too much while resizing...
        changed height => {
            debug("new height: ", self.height);
            udpate_visible_rows();
        }
        changed width => {
            debug("new width: ", self.width);
            sync_bucket_resolution();
            udpate_visible_rows();
        }
        TouchArea {
            width: 100%;
            property <int> step: 0;
            property <int> cols: root.grid_cols;
            property <length> gap: 0px;
            property <length> item_size: (parent.width - (cols + 1) * gap) / cols;
            property <int> rows: (root.grid_model.length + cols - 1) / cols;
            height: (rows * item_size) + ((rows + 1) * gap);

            scroll-event(event) => {
                if (event.modifiers.control) {
                    if event.delta-y > 0 {
                        step = -1;
                    } else if event.delta-y < 0 {
                        step = 1;
                    }
                    root.grid_cols = clamp(root.grid_cols + step, 2, 20);
                    sync_bucket_resolution();
                    udpate_visible_rows();
                    accept
                }
                reject
            }

            grid_container := Rectangle {
                width: parent.width;
                height: parent.height;
                property <length> item_size: parent.item_size;
                property <length> gap: parent.gap;
                property <int> cols: parent.cols;
                property <int> curr_bucket_res: 0;

                for item[i] in root.grid_model: Rectangle {
                    width: parent.item_size;
                    height: parent.item_size;
                    x: (Math.mod(i, parent.cols) * (parent.item_size + parent.gap)) + parent.gap;
                    y: (floor(i / parent.cols) * (parent.item_size + parent.gap)) + parent.gap;

                    clip: true;
                    Image {
                        source: item.image;
                        image-fit: cover;
                        width: 100%;
                        height: 100%;
                    }

                    TouchArea {
                        clicked => {
                            root.image_selected(item.index);
                            root.view_mode = ViewMode.full;
                        }
                    }
                }
            }
        }
    }

    full_view := TouchArea {
        property <length> last_coords_x: -1px;
        property <length> last_coords_y: -1px;
        property <string> display_coords: "0, 0";
        property <float> zoom_scale: 1.0;

        visible: root.view-mode == ViewMode.full;
        width: 100%;
        height: 100%;

        coords_timer := Timer {
            interval: 60ms;
            running: root.view-mode == ViewMode.full;
            triggered => {
                if (rect_img.mouse-x != last_coords_x || rect_img.mouse-y != last_coords_y) {
                    last_coords_x = rect_img.mouse-x;
                    last_coords_y = rect_img.mouse-y;
                    let win_w = full_view.width;
                    let win_h = full_view.height;
                    let img_w = root.full_view_image.width;
                    let img_h = root.full_view_image.height;

                    let scale = Math.min(win_w / img_w, win_h / img_h);
                    let off_x = (win_w - img_w * scale) / 2;
                    let off_y = (win_h - img_h * scale) / 2;
                    let x = clamp(Math.round((last_coords_x - off_x) / scale), 0, img_w);
                    let y = clamp(Math.round((last_coords_y - off_y) / scale), 0, img_h);

                    display_coords = x + "," + y;
                }
            }
        }

        function zoom(scale_delta: float, center_x: length, center_y: length) {
            let old_scale = zoom_scale;
            let new_scale = clamp(zoom_scale * scale_delta, 1, 10.0);

            if (old_scale == new_scale) {
                return;
            }
            zoom_scale = new_scale;
            let ratio = new_scale / old_scale;

            if (img.width == 0px || img.width == parent.width) {
                img.width = rect_img.width;
                img.height = rect_img.height;
                img.x = 0px;
                img.y = 0px;
            }
            img.width = img.width * ratio;
            img.height = img.height * ratio;

            img.x = center_x - (center_x - img.x) * ratio;
            img.y = center_y - (center_y - img.y) * ratio;

            debug("Zoom: " + Math.round(zoom_scale * 100) + "%");
        }

        function reset_zoom() {
            zoom_scale = 1;
            img.width = root.width;
            img.height = root.height;
            img.x = 0;
            img.y = 0;
        }

        scroll-event(event) => {
            let delta_up = event.delta-y > 0;
            if (event.modifiers.control) {
                zoom(delta_up ? 1.1 : 0.9, rect_img.mouse-x, rect_img.mouse-y);
            } else {
                reset_zoom();
                if (delta_up) {
                    root.request_prev_image();
                } else {
                    root.request_next_image();
                }
            }
            accept
        }

        rect_img := TouchArea {
            img := Image {
                source: root.full_view_image;
                image-fit: contain;
                width: 100%;
                height: 100%;
                x: 0px;
                y: 0px;
            }

            Rectangle {
                height: 16px;
                y: parent.height - self.height;
                width: 100%;
                background: #000000a0;
                Text {
                    x: 0px;
                    color: white;
                    text: (curr_image_index + 1) + "/" + grid_model.length;
                }

                Text {
                    color: white;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                    text: curr_image_name;
                }

                Text {
                    x: parent.width - self.width;
                    color: white;
                    text: "[x,y]=[" + display_coords + "]";
                }
            }

            ContextMenuArea {
                Menu {
                    MenuItem {
                        title: @tr("Rotate +90");
                        activated => {
                            debug("Rotate +90");
                            rotate_plus_90();
                        }
                    }

                    MenuItem {
                        title: @tr("Rotate -90");
                        activated => {
                            debug("Rotate -90");
                            rotate_minus_90();
                        }
                    }

                    MenuItem {
                        title: @tr("Reset zoom");
                        activated => {
                            debug("Reset zoom");
                            reset_zoom();
                        }
                    }
                }
            }
        }
    }
}
