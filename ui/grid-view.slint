import { ScrollView, LineEdit, Button } from "std-widgets.slint";
import { Theme } from "theme.slint";

export struct GridItem {
    image: image,
    index: int,
    selected: bool,
}

export enum MouseModeGrid {
    select,
    switch_to_full,
}

export component GridView inherits Rectangle {
    in property <[GridItem]> model;
    property <int> total_images: model.length;
    in-out property <int> grid_cols: 5;
    in-out property <int> selected_count: 0;
    property <int> last_clicked_index: -1;
    callback request_grid_data(int, int);
    callback image_selected(int);
    callback bucket_resolution_changed(int);
    callback search_submitted(string);
    callback toggle_select_all(bool);
    callback request_range_select(int, int);
    callback print_selected_paths();

    public function focus_search() {
        search_input.focus();
    }

    public function page_down() {
        grid_view.viewport-y = Math.max(
            grid_view.viewport-y - grid_view.height,
            grid_view.height - grid_view.viewport-height);
        update_visible_rows();
    }

    public function page_up() {
        grid_view.viewport-y = Math.min(
            grid_view.viewport-y + grid_view.height,
            0px);
        update_visible_rows();
    }

    public function toggle_mouse_mode() {
        grid_container.mouse_mode_grid = grid_container.mouse_mode_grid == MouseModeGrid.switch-to-full ? MouseModeGrid.select : MouseModeGrid.switch-to-full;
    }

    public function update_visible_rows() {
        let item_h = grid_container.item_size + grid_container.gap;
        let cols = grid_container.cols;

        if (item_h > 1px && root.height > 1px) {
            let start_row = floor(-grid_view.viewport-y / item_h);
            let screen_rows = ceil(grid_view.height / item_h);
            let buffer_rows = 5;
            let start_index = Math.max(0, (start_row - buffer_rows) * cols);
            let total_count = (screen_rows + (buffer_rows * 2)) * cols;
            root.request_grid_data(start_index, total_count);
        }
    }

    grid_header := Rectangle {
        width: 100%;
        y: 0px;
        height: 30px;
        background: Theme.surface-dark;
        property <length> font_size: 16px;

        HorizontalLayout {
            padding: 5px;
            spacing: 30px;
            Button {
                property <bool> is_selected: selected_count == 0 ? false : true;
                text: is_selected ? selected_count + "/" + total_images : total_images;
                clicked => {
                    selected_count = is_selected ? 0 : total_images;
                    root.toggle_select_all(is_selected);
                }
            }

            search_input := LineEdit {
                enabled: true;
                placeholder-text: "Search";
                font-size: font_size;
                accepted(text) => {
                    debug("accepted: ", text);
                    root.search_submitted(self.text);
                    self.clear-focus();
                }
                key-pressed(event) => {
                    if (event.text == Key.Escape) {
                        self.text = "";
                        root.search_submitted("");
                        self.clear-focus();
                        return accept;
                    }
                    reject
                }
            }

            Text {
                horizontal-alignment: right;
                vertical-alignment: center;
                font-size: font_size;
                color: Theme.text-main;
                text: "mode: " + (grid_container.mouse_mode_grid == MouseModeGrid.switch-to-full ? "F" : "S");
            }
        }
    }

    grid_view := ScrollView {
        y: grid_header.height;
        viewport-height: grid_container.height;
        property <[length]> resolutions: [256 * 1px, 512 * 1px, 1024 * 1px];

        function bucket_resolution(size: length) -> int {
            if size < resolutions[0] {
                return resolutions[0] / 1px;
            }
            if size < resolutions[1] {
                return resolutions[1] / 1px;
            }
            return resolutions[2] / 1px;
        }

        function sync_bucket_resolution() {
            let new_bucket_res = bucket_resolution(grid_container.item_size);
            if (new_bucket_res != grid_container.curr_bucket_res) {
                grid_container.curr_bucket_res = new_bucket_res;
                root.bucket_resolution_changed(new_bucket_res);
            }
        }

        scrolled => {
            root.update_visible_rows();
        }
        init => {
            root.update_visible_rows();
        }
        changed height => {
            root.update_visible_rows();
        }
        changed width => {
            sync_bucket_resolution();
            root.update_visible_rows();
        }

        grid := TouchArea {
            property <int> step: 0;
            property <int> cols: root.grid_cols;
            property <length> gap: 0px;
            property <length> item_size: (parent.width - (cols + 1) * gap) / cols;
            property <int> rows: (root.model.length + cols - 1) / cols;
            height: (rows * item_size) + ((rows + 1) * gap);

            scroll-event(event) => {
                if (event.modifiers.control) {
                    if event.delta-y > 0 {
                        step = -1;
                    } else if event.delta-y < 0 {
                        step = 1;
                    }
                    root.grid_cols = clamp(root.grid_cols + step, 2, 20);
                    grid_view.sync_bucket_resolution();
                    root.update_visible_rows();
                    accept
                } else {
                    reject
                }
            }

            grid_container := Rectangle {
                width: parent.width;
                height: parent.height;
                property <length> item_size: parent.item_size;
                property <length> gap: parent.gap;
                property <int> cols: parent.cols;
                property <int> curr_bucket_res: 0;
                property <MouseModeGrid> mouse_mode_grid: MouseModeGrid.switch-to-full;

                for item[i] in root.model: Rectangle {
                    width: parent.item_size;
                    height: parent.item_size;
                    x: (Math.mod(i, parent.cols) * (parent.item_size + parent.gap)) + parent.gap;
                    y: (floor(i / parent.cols) * (parent.item_size + parent.gap)) + parent.gap;

                    clip: true;
                    border-width: item.selected ? 3px : 0px;
                    border-color: Theme.primary;
                    opacity: item.selected ? 0.7 : 1.0;

                    Image {
                        source: item.image;
                        image-fit: cover;
                        width: 100%;
                        height: 100%;
                    }

                    TouchArea {
                        pointer-event(event) => {
                            if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                                if (event.modifiers.control) {
                                    item.selected = !item.selected;
                                    selected_count += item.selected ? 1 : -1;
                                    root.last_clicked_index = i;
                                } else if (event.modifiers.shift && root.last_clicked_index != -1) {
                                    root.request_range_select(root.last_clicked_index, i);
                                }
                                // TODO:
                                // } else {
                                //     root.toggle_select_all(false);
                                //     item.selected = true;
                                //     selected_count = 1;
                                //     root.last_clicked_index = i;
                                // }
                            }
                        }
                        double-clicked() => {
                            root.image_selected(item.index);
                        }
                    }
                }
            }
        }

        ContextMenuArea {
            Menu {
                MenuItem {
                    title: @tr("Print selected paths to stdout");
                    activated => {
                        print_selected_paths();
                    }
                }
            }
        }
    }
}
